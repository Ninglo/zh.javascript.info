importance: 5

---

# 防抖装饰者

`debounce(f, ms)` 装饰器的结果是一个包装函数，其将对 `f` 的调用挂起直到经过 `ms` 毫秒的非活动状态(无函数调用，“冷却期”)，然后携带最后一次请求的参数调用 `f`。

换句话说，`debounce` 就像一个'接听电话'的秘书，并且等待 `ms` 毫秒的片刻安静。之后仅传递最后一次电话的内容给“老板” (调用真正的 `f`)。

举个例子，我们将一个函数 `f` 替代为 `f = debounce(f, 1000)`。

如果在 0ms、200ms 和 500ms 时调用这个包装函数，之后不再调用，那么真正的 `f` 只会在 1500ms 时被调用一次。也就是：从最后一次调用开始的 1000ms 冷却期之后。

![](debounce.svg)

...并且它会携带最后一次调用的所有请求，其他的请求将被忽略。

以下是它的代码 (使用 [Lodash library](https://lodash.com/docs/4.17.15#debounce) 的防抖装饰者):

```js
let f = _.debounce(alert, 1000);

f("a");
setTimeout( () => f("b"), 200);
setTimeout( () => f("c"), 500);
// 防抖函数从最后一次函数调用以后等待 1000ms，然后运行：alert("c")
```

以下是一个实际的例子。假设用户输入了一些内容，当输入完成时，我们向服务器发送一个请求。

没必要为了每一个字符的输入而发送请求。相反，我们可以稍等片刻，然后发送整个结果。

在浏览器中，我们可以设置一个事件处理程序 —— 一个每次输入内容发送变化都会调用的函数。通常，监听所有键盘输入的事件处理程序会被调用的非常频繁。但是如果我们为这个程序做 1000ms 的 `debounce` 处理，它就只会被调用一次，在最后一次输入后的 1000ms 后。

```online

在这个实时实例中，处理程序将将结果放置下面的盒子中，试试看:

[iframe border=1 src="debounce" height=200]

看到了吗？第二个输入框调用了防抖函数，所以它的内容在最后一次输入的 1000ms 后被处理。
```

因此，`debounce` 是一个处理一连串事件的好方法：无论是一串键盘输入，鼠标移动还是其他类似的事件。

它在最后一次调用后等待给定的时间，然后运行其处理结果的函数。

任务是实现一个 `debounce` 装饰者。

提示: 如果你仔细考虑，它仅仅需要几行内容 :)
